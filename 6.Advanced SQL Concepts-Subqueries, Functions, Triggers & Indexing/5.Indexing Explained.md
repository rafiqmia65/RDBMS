# ðŸ“˜ Database Indexing Explained (SQL)

## ðŸ”¹ What is an Index?

A **database index** is a **special data structure** that helps the database **find rows faster** in a table without scanning every row.

> Think of it like the **index in a book**: instead of reading every page, you jump directly to the page you want.

---

## ðŸ”¹ Why Use Indexes? (Purpose / Use Case)

Indexes are **used to improve database performance** in several ways:

1. **Faster Data Retrieval**

   - Queries like `SELECT * FROM employees WHERE name = 'Rafiq';` are much faster.
   - Without an index, PostgreSQL performs a **full table scan**.

2. **Efficient Searching**

   - Large tables with millions of rows can be searched quickly.
   - Example: searching for customers by email or ID.

3. **Quick Sorting**

   - Queries with `ORDER BY` benefit from indexes.
   - Example:

   ```sql
   SELECT * FROM employees ORDER BY salary DESC;
   ```

4. **Join Performance**

   - Indexes improve **JOIN operations** between tables.
   - Example: Joining employees and departments on `dept_id`.

5. **Enforce Uniqueness**

   - Unique indexes ensure **no duplicate values**.
   - Example: email column in `users` table.

6. **Support Partial Queries**

   - Partial indexes allow indexing only **rows matching specific criteria**.
   - Example: indexing only active employees.

---

## ðŸ”¹ Types of Indexes in PostgreSQL

| Index Type     | Purpose / Use Case                                                      |
| -------------- | ----------------------------------------------------------------------- |
| **B-Tree**     | Default; equality & range queries; fast lookups and sorting             |
| **Hash**       | Equality checks only; rarely used                                       |
| **GIN**        | Full-text search, arrays, JSONB                                         |
| **GiST**       | Geometric, spatial, or complex data types                               |
| **BRIN**       | Huge tables with sequential data; low storage cost                      |
| **Unique**     | Enforces uniqueness on columns (like email)                             |
| **Partial**    | Indexes only subset of rows; saves space                                |
| **Expression** | Index on computed value (e.g., LOWER(name) for case-insensitive search) |

---

## ðŸ”¹ Real-world Scenarios / Examples

### 1ï¸âƒ£ Searching Employees by Name

```sql
CREATE INDEX idx_employee_name ON employees(name);
```

- Query:

```sql
SELECT * FROM employees WHERE name = 'Rafiq';
```

- **Without index:** full table scan
- **With index:** database directly jumps to relevant rows â†’ **faster**

---

### 2ï¸âƒ£ Enforcing Unique Emails

```sql
CREATE UNIQUE INDEX idx_unique_email ON employees(email);
```

- Ensures no duplicates
- Fast retrieval by email

---

### 3ï¸âƒ£ Multi-column Filtering

```sql
CREATE INDEX idx_name_salary ON employees(name, salary);
```

- Example query:

```sql
SELECT * FROM employees
WHERE name='Rafiq' AND salary>5000;
```

- Improves queries filtering on **multiple columns together**

---

### 4ï¸âƒ£ Partial Index for High Salary Employees

```sql
CREATE INDEX idx_high_salary ON employees(salary) WHERE salary>10000;
```

- Only indexes rows where salary > 10000
- Saves storage and improves **targeted query performance**

---

### 5ï¸âƒ£ Expression Index (Case-Insensitive Search)

```sql
CREATE INDEX idx_lower_name ON employees(LOWER(name));
```

- Query:

```sql
SELECT * FROM employees WHERE LOWER(name)='rafiq';
```

- Works well for **case-insensitive matching**

---

## ðŸ”¹ Viewing Indexes

```sql
-- List indexes on a table
\d employees

-- Or SQL
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename='employees';
```

---

## ðŸ”¹ Dropping an Index

```sql
DROP INDEX idx_employee_name;
```

> Removing the index **does not delete table data**, only the index.

---

## ðŸ”¹ Best Practices

- âœ… Index columns used frequently in **WHERE, JOIN, ORDER BY**
- âœ… Avoid indexing columns with **low selectivity** (e.g., boolean flags)
- âœ… Use **composite indexes** only when necessary
- âœ… Consider **storage & maintenance cost**
- âœ… Always check **query plan** (`EXPLAIN`) to ensure index is used

---

## ðŸ”¹ Index vs Table Scan

| Feature     | Index Scan                     | Sequential Scan (No Index) |
| ----------- | ------------------------------ | -------------------------- |
| Speed       | Fast (selective queries)       | Slow on large tables       |
| Cost        | Extra storage                  | No extra storage           |
| Maintenance | Needed on INSERT/UPDATE/DELETE | None                       |
| Use Case    | Lookups, JOIN, ORDER BY        | Full table reads           |

---

## ðŸ”¹ Summary

- Indexes **accelerate queries**, reduce full table scans.
- Essential for **large tables** or frequently searched columns.
- Choose **type of index** depending on query type (B-Tree, GIN, BRIN, etc.).
- Balance **query speed vs storage & write cost**.
- A **critical topic** for performance tuning and database design.

---

**Author:** Md Rafiq Mia
**Use Case:** PostgreSQL / SQL Performance Optimization Documentation
